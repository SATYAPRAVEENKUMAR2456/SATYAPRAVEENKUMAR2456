# -*- coding: utf-8 -*-
"""Crypto prediction using machine learning on Bitcoin_USD.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gSxbt3E_dBNVHuhiCv22wsZJz-a_96y6
"""

!pip install yfinance

import yfinance as yf
import numpy as np

df=yf.download('BTC-USD',start='2018-01-01')

df.head()

df['returns']=np.log(df.Close.pct_change()+1)

def lagit(df,lags):
    names=[]
    for i in range(1,lags+1):
        df['Lag_'+str(i)]=df['returns'].shift(i)
        names.append('Lag_'+str(i))
    return names

lagnames=lagit(df,5)

df.dropna(inplace=True)

"""LINEAR REGRESSION"""

from sklearn.linear_model import LinearRegression
model=LinearRegression()
model.fit(df[lagnames],df['returns'])

df['prediction_LR']=model.predict(df[lagnames])
df['direction_LR']=[1 if i>0 else -1 for i in df['prediction_LR']]
df['strat_LR']=df['direction_LR']*df['returns']
np.exp(df[['returns','strat_LR']].sum())

np.exp(df[['returns','strat_LR']].cumsum()).plot()

from sklearn.model_selection import train_test_split
train,test=train_test_split(df,shuffle=False,test_size=0.3,random_state=0)

train=train.copy()
test=test.copy()
model=LinearRegression()
model.fit(train[lagnames],train['returns'])
test['prediction_LR']=model.predict(test[lagnames])
test['direction_LR']=[1 if i>0 else -1 for i in test.prediction_LR]
test['strat_LR']=test['direction_LR']*test['returns']
np.exp(test[['returns','strat_LR']].sum())

(test['direction_LR'].diff()!=0).value_counts()

np.exp(test[['returns','strat_LR']].cumsum()).plot()

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
# %matplotlib inline
import matplotlib

m = pd.read_csv("/content/sample_data/BTC-USD.csv.zip", names = ['Time','Low','High','Open','Close','Volume'])

m.head()

nr = m[m['Time'] == 'n/r'].index
m.drop(nr, inplace=True)
nr = m[m['Time'] == 'canc '].index
m.drop(nr, inplace=True)
nr = m[m['Time'] == 'aban '].index
m.drop(nr, inplace=True)
print(m.shape)
m.head()

print("\n\n")

nr = m[m['Low'] == 'n/r'].index
m.drop(nr, inplace=True)
nr = m[m['Low'] == 'canc '].index
m.drop(nr, inplace=True)
nr = m[m['Low'] == 'aban '].index
m.drop(nr, inplace=True)
print(m.shape)
m.head()

print("\n\n")

nr = m[m['High'] == 'n/r'].index
m.drop(nr, inplace=True)
nr = m[m['High'] == 'canc '].index
m.drop(nr, inplace=True)
nr = m[m['High'] == 'aban '].index
m.drop(nr, inplace=True)
print(m.shape)
m.head()

print("\n\n")

nr = m[m['Open'] == 'n/r'].index
m.drop(nr, inplace=True)
nr = m[m['Open'] == 'canc '].index
m.drop(nr, inplace=True)
nr = m[m['Open'] == 'aban '].index
m.drop(nr, inplace=True)
print(m.shape)
m.head()

print("\n\n")

nr = m[m['Close'] == 'n/r'].index
m.drop(nr, inplace=True)
nr = m[m['Close'] == 'canc '].index
m.drop(nr, inplace=True)
nr = m[m['Close'] == 'aban '].index
m.drop(nr, inplace=True)
print(m.shape)
m.head()

print("\n\n")

nr = m[m['Volume'] == 'n/r'].index
m.drop(nr, inplace=True)
nr = m[m['Volume'] == 'canc '].index
m.drop(nr, inplace=True)
nr = m[m['Volume'] == 'aban '].index
m.drop(nr, inplace=True)
print(m.shape)
m.head()

Time = m['Time'].unique()
Time
tim = {}
id = 0
for i in Time:
  tim[i] = id
  id = id+1
print(tim)
m['Time'] = m['Time'].map(tim)
m

print("\n\n")

Low = m['Low'].unique()
Low
low = {}
id = 0
for i in Low:
  low[i] = id
  id = id+1
print(low)
m['Low'] = m['Low'].map(low)
m

print("\n\n")

High = m['High'].unique()
High
hig = {}
id = 0
for i in High:
  hig[i] = id
  id = id+1
print(hig)
m['High'] = m['High'].map(hig)
m

print("\n\n")

Open = m['Open'].unique()
Open
ope = {}
id = 0
for i in Open:
  ope[i] = id
  id = id+1
print(ope)
m['Open'] = m['Open'].map(ope)
m

print("\n\n")

Close = m['Close'].unique()
Close
clo = {}
id = 0
for i in Close:
  clo[i] = id
  id = id+1
print(clo)
m['Close'] = m['Close'].map(clo)
m

print("\n\n")

Volume = m['Volume'].unique()
Volume
vol = {}
id = 0
for i in Volume:
  vol[i] = id
  id = id+1
print(vol)
m['Volume'] = m['Volume'].map(vol)
m

m.dropna()
plt.figure(figsize=(10,4))
plt.title("BitCoin price USA")
plt.xlabel("Time")
plt.ylabel("High")
plt.plot(m["High"])
plt.show()

sns.pairplot(data=m,hue='High')

"""#Linear_Regression"""

import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.feature_selection import  SelectKBest
from sklearn.feature_selection import f_regression

def Select_features(x_train, y_train, x_test):
  fs = SelectKBest(score_func=f_regression, k ='all')
  fs.fit(x_train, y_train)
  x_train_fs = fs.transform(x_train)
  x_test_fs = fs.transform(x_test)
  return x_train_fs, x_test_fs, fs

m2 = m
m2.head()

y = m2["Volume"]
x = m2[['Time','High','Low','Open','Close']]

x_train, x_test, y_train, y_test = train_test_split(x,y,test_size=0.4,random_state=12)

x_train_fs, x_test_fs, fs = Select_features(x_train, y_train, x_test)

for i in range(len(fs.scores_)):
  print('Features %d: %f' %(i,fs.scores_[i]))


plt.bar([i for i in range(len(fs.scores_))], fs.scores_)
plt.show()

linear_regression = LinearRegression()
linear_regression.fit(x_train,y_train)

print("coefficients: \n",linear_regression.coef_)
print("Variance: \n",linear_regression.score(x_test,y_test))

plt.scatter(linear_regression.predict(x_test),linear_regression.predict(x_test)-y_test, color="green", label="Test data")
plt.scatter(linear_regression.predict(x_train),linear_regression.predict(x_train)-y_train, color="black", label="Train data")

plt.hlines(y=0, xmin=65,xmax=100,linewidth=2)

from sklearn.preprocessing import PolynomialFeatures
from sklearn.metrics import r2_score

poly_reg = PolynomialFeatures(degree=2)
x = poly_reg.fit_transform(x)


x_train, x_test, y_train, y_test = train_test_split(x,y,test_size=0.4,random_state=10)


linear_regression = LinearRegression()
linear_regression.fit(x_train,y_train)


print("Coefficients: \n",linear_regression.coef_)
print("Variance: \n",linear_regression.score(x_test,y_test))
print("R2: \n",r2_score(y_train, linear_regression.predict(x_train)))

"""#M_LR"""

from sklearn import linear_model
import statsmodels.api as sm
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt
from sklearn.metrics import r2_score

plt.scatter(m["Time"],m["Open"],color="red")
plt.scatter(m["Open"],m["High"],color="brown")
plt.title("Time vs High")
plt.show()

plt.scatter(m["Open"],m["High"],color="blue")
plt.scatter(m["High"],m["Low"],color="green")
plt.title("Open vs Low")
plt.show()

plt.scatter(m["Open"],m["Close"],color="black")
plt.scatter(m["High"],m["Low"],color="green")
plt.title("Open_close vs High_Low")
plt.show()

plt.scatter(m["Open"],m["Close"],color="violet")
plt.scatter(m["High"],m["Low"],color="black")
plt.title("Open vs Low")
plt.show()

plt.scatter(m["Time"],m["Volume"],color="yellow")
plt.scatter(m["Open"],m["Volume"],color="black")
plt.title("DV vs OV")
plt.show()

x=m[["Open","High","Low","Close","Volume"]]
y=m['Time']
xtrain,xtest,ytrain,ytest=train_test_split(x,y,test_size=0.3,random_state=10)
MLR=linear_model.LinearRegression()
MLR.fit(xtrain,ytrain)
trainpredict=MLR.predict(xtrain)
testpredict=MLR.predict(xtest)
print("\nslope: ",MLR.coef_)
print("\nIntrest_get: ",MLR.intercept_*100)
print("\nThe Loss: ",r2_score(ytest,testpredict))
print("\nThe given Y values: \n",ytest)
plt.boxplot(testpredict)

"""K_Means"""

from sklearn.cluster import KMeans

df = m
df.head()
X=df[['Open','High']]
X=X.to_numpy()

model=KMeans(n_clusters=5)
model.fit(X)
yhat=model.predict(X)
print(yhat)

from numpy import unique,where

clusters=unique(yhat)
print(clusters)

for i in clusters:
  row_id=where(yhat==i)
  plt.scatter(X[row_id,0],X[row_id,1])
plt.show()

"""#Navie_Bayes"""

df2 = pd.read_csv("/content/sample_data/BTC-USD.csv.zip", names = ['Time','Low','High','Open','Close','Volume'])
print(df2.columns)
df2.head()

nr = df2[df2['Time'] == 'n/r'].index
df2.drop(nr, inplace=True)
nr = df2[df2['Time'] == 'canc '].index
df2.drop(nr, inplace=True)
nr = df2[df2['Time'] == 'aban '].index
df2.drop(nr, inplace=True)
print(df2.shape)
df2.head()

print("\n\n")

nr = df2[df2['Low'] == 'n/r'].index
df2.drop(nr, inplace=True)
nr = df2[df2['Low'] == 'canc '].index
df2.drop(nr, inplace=True)
nr = df2[df2['Low'] == 'aban '].index
df2.drop(nr, inplace=True)
print(df2.shape)
df2.head()

print("\n\n")

nr = df2[df2['High'] == 'n/r'].index
df2.drop(nr, inplace=True)
nr = df2[df2['High'] == 'canc '].index
df2.drop(nr, inplace=True)
nr = df2[df2['High'] == 'aban '].index
df2.drop(nr, inplace=True)
print(df2.shape)
df2.head()

print("\n\n")

nr = df2[df2['Open'] == 'n/r'].index
df2.drop(nr, inplace=True)
nr = df2[df2['Open'] == 'canc '].index
df2.drop(nr, inplace=True)
nr = df2[df2['Open'] == 'aban '].index
df2.drop(nr, inplace=True)
print(df2.shape)
df2.head()

print("\n\n")

nr = df2[df2['Close'] == 'n/r'].index
df2.drop(nr, inplace=True)
nr = df2[df2['Close'] == 'canc '].index
df2.drop(nr, inplace=True)
nr = df2[df2['Close'] == 'aban '].index
df2.drop(nr, inplace=True)
print(df2.shape)
df2.head()

print("\n\n")

nr = df2[df2['Volume'] == 'n/r'].index
m.drop(nr, inplace=True)
nr = df2[df2['Volume'] == 'canc '].index
df2.drop(nr, inplace=True)
nr = df2[df2['Volume'] == 'aban '].index
df2.drop(nr, inplace=True)
print(df2.shape)
df2.head()

Time = df2['Time'].unique()
Time
tim = {}
id = 0
for i in Time:
  tim[i] = id
  id = id+1
print(tim)
df2['Time'] = df2['Time'].map(tim)
df2

print("\n\n")

Low = df2['Low'].unique()
Low
low = {}
id = 0
for i in Low:
  low[i] = id
  id = id+1
print(low)
df2['Low'] = df2['Low'].map(low)
df2

print("\n\n")

High = df2['High'].unique()
High
hig = {}
id = 0
for i in High:
  hig[i] = id
  id = id+1
print(hig)
df2['High'] = df2['High'].map(hig)
df2

print("\n\n")

Open = df2['Open'].unique()
Open
ope = {}
id = 0
for i in Open:
  ope[i] = id
  id = id+1
print(ope)
df2['Open'] = df2['Open'].map(ope)
df2

print("\n\n")

Close = df2['Close'].unique()
Close
clo = {}
id = 0
for i in Close:
  clo[i] = id
  id = id+1
print(clo)
df2['Close'] = df2['Close'].map(clo)
df2

print("\n\n")

Volume = df2['Volume'].unique()
Volume
vol = {}
id = 0
for i in Volume:
  vol[i] = id
  id = id+1
print(vol)
df2['Volume'] = df2['Volume'].map(vol)
df2

print(df2['Time'].value_counts())
print(df2['Open'].value_counts())
print(df2['High'].value_counts())
print(df2['Low'].value_counts())
print(df2['Close'].value_counts())
print(df2['Volume'].value_counts())

from sklearn.model_selection import train_test_split
from sklearn.impute import SimpleImputer
from sklearn.naive_bayes import GaussianNB
from sklearn import metrics
import warnings
warnings.filterwarnings('ignore')

X = df2[['Time','Open','Low','Volume']]
y = df2['High']


xtrain,xtest,ytrain,ytest, = train_test_split(x,y,test_size=0.90,random_state=125)

model = GaussianNB()

model.fit(xtrain,ytrain)
ypred = model.predict(xtest)

print("Accuracy: ",metrics.accuracy_score(ytest, ypred))

"""#Desicion_Tree"""

from sklearn import tree
import pydotplus
from sklearn.tree import DecisionTreeClassifier
import matplotlib.pyplot as plt
import matplotlib.image as pltimg
from sklearn.model_selection import train_test_split
from sklearn import metrics

df4 = df2
print(df4.columns)
df4.head()

from sklearn.preprocessing import LabelEncoder
le=LabelEncoder()
df4['High'] = le.fit_transform(df['High'])
print(df4.head())
print("High_value: ",df4['High'].value_counts())

from sklearn import tree
import pydotplus
from sklearn.tree import DecisionTreeClassifier
import matplotlib.pyplot as plt
import matplotlib.image as pltimg
from sklearn.model_selection import train_test_split
from sklearn import metrics

features = ['Time','Open','Low','Volume']

x = df4[features]
y = df4['High']

xtrain,xtest,ytrain,ytest, = train_test_split(x,y,test_size=0.99,random_state=210)

dtree = DecisionTreeClassifier()
dtree = dtree.fit(xtrain,ytrain)

ypred = dtree.predict(xtest)
print("Accuracy: ",metrics.accuracy_score(ytest, ypred))

data = tree.export_graphviz(dtree, out_file=None, feature_names=features)
graph = pydotplus.graph_from_dot_data(data)
graph.write_png('decisiontree_matresult.png')

img = pltimg.imread('decisiontree_matresult.png')
imgplot = plt.imshow(img)
plt.show()